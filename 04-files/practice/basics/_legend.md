# Basics

Перед началом выполнения заданий этого блока,
следует ознакомиться с основами работы с файлами в Python
(например, по [этой ссылке](https://tproger.ru/articles/files-in-python/)).

Выполнять задания следует в следующем порядке:
- `text.py`
- `table_of_contents.py`
- `binary.py`

## `text.py`

Задания на работу с текстовыми файлами.

Следует обратить внимание:
- На ОС Windows, функция `file.seek()` считает перенос строки как **два символа**
- Конструкция `for line in file` будет выдавать символ переноса строки в конце строк `line`
- При попытке писать не в конец файла, функция `file.write()` будет писать ПОВЕРХ старых символов
- `file.write()` НЕ добавляет перенос строк автоматически. Для перехода на новую строку, используйте символ `'\n'`

### `read_all`
Аргумент filename содержит название текстового файла.
Необходимо прочитать содержимое указанного файла и вернуть его как строку.

### `sum_two`
Аргумент `filename` содержит название текстового файла.
Указанный файл содержит некоторое количество целых чисел, разделенных пробелами (не менее двух).
Необходимо прочитать первые два целых числа и вернуть их сумму.

Пример: есть файл abc.txt с содержимым:
```
111 222 555 1 4 324342
```
Функция `sum_two('abc.txt')` должна вернуть 333.

### `longest_line`
Вернуть номер самой длинной строки текстового файла `filename`.
Нумерацию строк начинать с единицы.
Если в ответе несколько строк равной длины, вернуть наименьший из индексов.

### `random_access`
Вернуть `n`-ый символ текстового файла `filename`.
Нумерацию символов начинать с единицы. Перенос строки тоже считается символом.

Если символа с таким индексом нет или `n` не положителен, вернуть пустую строку.

Пример: есть файл abc.txt с содержимым:
```
Very nice
and fun
```

Тогда:
```python
random_access('abc.txt', 7) -> 'i'
random_access('abc.txt', 13) -> 'd'
random_access('abc.txt', 100000) -> ''
```

### `alphabet`
Вывести `n` первых заглавных букв латинского алфавита в текстовый файл с названием `filename`.

Если файл уже существует, содержимое необходимо перезаписать на требуемое по заданию.
Если файл не существует, нужно его создать.

## `table_of_contents.py`
Входной текстовый файл содержит некоторое количество строк.

Если строка начинается с решетки (#), то остальное её содержимое - это заголовок.

В конец файла нужно добавить оглавление - заголовки и их номера строк (отсчёт с единицы).

Каждый заголовок - с новой строки, в след. формате: "номер.....заголовок".

В начало файла следует дописать строку с номером, с которого начинается оглавление.

Добавленную в начало строку НЕ учитывать при постороении оглавления, но учитывать для подсчёта его позиции.

**Например**, если исходный файл выглядит так:
```
#aaaa
bbbb
#cccc
dddd
```

То итоговый файл должен выглядеть так:
```
6
#aaaa
bbbb
#cccc
dddd
1.....aaaa
3.....cccc
```

## `binary.py`

Перед началом выполнения этих заданий, рекомендуется ознакомиться с гайдом `_legend_binary.md`.

_Примечание: во всех заданиях, связанных с бинарными файлами, в качестве
порядка байтов в числах используется
Big Endian (`byteorder='big'`). Тип int подразумевает `signed=True`._

### `bin_sum_two`
Бинарный файл с названием `filename` содержит некоторое количество целых чисел (не менее двух).

Каждое число имеет тип int и закодировано строго четырьмя идущими подряд байтами.
Никаких дополнительных разделителей между числами нет.

Реализуемая функция должна прочитать первые два числа и вернуть их сумму.

### `find_person`
Бинарный файл `filename` содержит информацию о людях и имеет следующую структуру:

- число K (int, 4 байта) - количество записей
- далее идут K записей:
  - число ID (int, 4 байта) - уникальный численный идентификатор
  - число N (int, 4 байта) - количество байт, которыми закодировано ФИО
  - строка ФИО, закодированная N байтами (кодировка - 'UTF-8')

Функция `find_person` принимает в качестве аргументов имя файла `filename` и численный идентификатор `identifier`.

Необходимо реализовать эту функцию таким образом, чтобы она возвращала ФИО человека, имеющего указанный идентификатор.
